import { property } from 'lit/decorators.js';
import { AuthorizationMethodElement as AuthorizationMethod, AuthUiBase, AuthUiInit } from "@advanced-rest-client/base";
import { ApiDefinitions } from "@api-client/core/build/browser.js";
import {
  normalizeType,
  METHOD_OAUTH2,
  METHOD_OAUTH1,
  METHOD_BASIC,
  METHOD_BEARER,
  METHOD_NTLM,
  METHOD_DIGEST,
  METHOD_OIDC,
} from "@advanced-rest-client/base/src/elements/authorization/Utils.js";
import {
  typeChangedSymbol,
  renderCallback,
  changeCallback,
  factory,
  propagateChanges,
} from "@advanced-rest-client/base/src/elements/authorization/AuthorizationMethodElement.js";
import { ApiAuthDataHelper } from "../lib/ApiAuthDataHelper.js";
import * as InputCache from "../lib/InputCache.js";
import styles from './styles/AuthorizationMethod.js';
import { EventTypes } from '../events/EventTypes.js';
import ApiUiBase from '../lib/auth-ui/ApiUiBase.js';
import CustomAuth from '../lib/auth-ui/CustomAuth.js';
import PassThroughAuth from '../lib/auth-ui/PassThroughAuth.js';
import ApiKeyAuth from '../lib/auth-ui/ApiKeyAuth.js';


export const METHOD_CUSTOM = "custom";
export const METHOD_PASS_THROUGH = "pass through";
export const METHOD_API_KEY = "api key";
export const initApiFactory = Symbol("initApiFactory");
export const apiValue = Symbol("apiValue");
export const settingsHandler = Symbol("settingsHandler");

export default class ApiAuthorizationMethodElement extends AuthorizationMethod {
  static get styles(): CSSResult[] {
    return [super.styles, styles];
  }

  /**
   * A security model generated by the AMF parser.
   */
  @property({ type: Object })
  security?: ApiDefinitions.IApiParametrizedSecurityScheme;

  /**
   * When set the "description" of the security definition is rendered.
   * @attribute
   */
  @property({ type: Boolean, reflect: true })
  descriptionOpened?: boolean;

  /**
   * By default the element stores user input in a map that is associated with the specific
   * instance of this element. This way the element can be used multiple times in the same document.
   * However, this way parameter values generated by the generators or entered by the user won't
   * get populated in different operations.
   *
   * By setting this value the element prefers a global cache for values. Once the user enter
   * a value it is registered in the global cache and restored when the same parameter is used again.
   *
   * Do not use this option when the element is embedded multiple times in the page. It will result
   * in generating request data from the cache and not what's in the form inputs and these may not be in sync.
   *
   * These values are stored in memory only. Listen to the `change` event to learn that something changed.
   * @attribute
   */
  @property({ type: Boolean, reflect: true })
  globalCache?: boolean;


  /**
   * Used by the OAuth 2 type.
   * When set it overrides the `authorizationUri` in the authorization editor,
   * regardless to the authorization scheme applied to the request.
   * This is to be used with the mocking service.
   * @attribute
   */
  @property({ type: String })
  overrideAuthorizationUri?: string;

  /**
   * Used by the OAuth 2 type.
   * When set it overrides the `authorizationUri` in the authorization editor,
   * regardless to the authorization scheme applied to the request.
   * This is to be used with the mocking service.
   * @attribute
   */
  @property({ type: String })
  overrideAccessTokenUri?: string;

  constructor() {
    super();
    this[settingsHandler] = this[settingsHandler].bind(this);
  }

  connectedCallback(): void {
    InputCache.registerLocal(this);
    this.addEventListener(EventTypes.Security.settingsChanged, this[settingsHandler] as EventListener);
    super.connectedCallback();
  }

  disconnectedCallback(): void {
    this.removeEventListener(EventTypes.Security.settingsChanged, this[settingsHandler] as EventListener);
    super.disconnectedCallback();
  }

  /**
   * Validates current method.
   */
  validate(): boolean {
    const instance = this[factory] as ApiUiBase;
    const type = normalizeType(this.type);
    switch(type) {
      case METHOD_CUSTOM: 
      case METHOD_PASS_THROUGH:
      case METHOD_API_KEY: return instance.validate();
      default: return super.validate();
    }
  }

  /**
   * A handler for the global authorization settings change event.
   * It applies the the event settings to the current configuration.
   */
  [settingsHandler](e: CustomEvent): void {
    const { detail } = e;
    const cp = { ...detail };
    // compatibility with 2.0
    if (cp.headers) {
      cp.header = cp.headers;
      delete cp.headers;
    }
    if (cp.params) {
      cp.query = cp.params;
      delete cp.params;
    }
    const serialized = this.serialize();
    this.restore({ ...serialized, ...cp });
  }

  /**
   * A function called when `type` changed.
   * Note, that other properties may not be initialized just yet.
   *
   * @param type Current value.
   */
  async [typeChangedSymbol](type: string): Promise<void> {
    const init: AuthUiInit = ({
      renderCallback: this[renderCallback],
      changeCallback: this[changeCallback],
      target: this,
      readOnly: this.readOnly,
      disabled: this.disabled,
      anypoint: this.anypoint,
      outlined: this.outlined,
      authorizing: this.authorizing,
    });
    let instance: AuthUiBase;
    const normalized = normalizeType(type);
    switch (normalized) {
      case METHOD_BASIC:
        instance = ApiAuthDataHelper.setupBasic(this, init);
        break;
      case METHOD_BEARER:
        instance = ApiAuthDataHelper.setupBearer(this, init);
        break;
      case METHOD_NTLM:
        instance = ApiAuthDataHelper.setupNtlm(this, init);
        break;
      case METHOD_DIGEST:
        instance = ApiAuthDataHelper.setupDigest(this, init);
        break;
      case METHOD_OIDC:
        instance = ApiAuthDataHelper.setupOidc(this, init);
        break;
      case METHOD_CUSTOM:
        instance = ApiAuthDataHelper.setupCustom(this, init);
        break;
      case METHOD_OAUTH2:
        instance = ApiAuthDataHelper.setupOauth2(this, init);
        break;
      case METHOD_OAUTH1:
        instance = ApiAuthDataHelper.setupOauth1(this, init);
        break;
      case METHOD_PASS_THROUGH:
        instance = ApiAuthDataHelper.setupPassThrough(this, init);
        break;
      case METHOD_API_KEY:
        instance = ApiAuthDataHelper.setupApiKey(this, init);
        break;
      default:
        throw new Error(`Unsupported authorization type ${type}`);
    }
    this[factory] = instance;
    instance.defaults();
    this.requestUpdate();
    await this.updateComplete;
    this.dispatchEvent(new Event('resize', { bubbles: true, composed: true }));
  }

  /**
   * Propagates values from the UI factory to this element.
   * This is to synchronize user entered values with the element's state.
   */
  [propagateChanges](): void {
    switch (normalizeType(this.type)) {
      case METHOD_CUSTOM:
        ApiAuthDataHelper.populateCustom(this, (this[factory] as CustomAuth));
        break;
      case METHOD_PASS_THROUGH:
        ApiAuthDataHelper.populatePassThrough(this, (this[factory] as PassThroughAuth));
        break;
      case METHOD_API_KEY:
        ApiAuthDataHelper.populateApiKey(this, (this[factory] as ApiKeyAuth));
        break;
      default:
        super[propagateChanges]();
    }
  }

  /**
   * Updates, if applicable, query parameter value.
   * This is supported for RAML custom scheme and Pass Through
   * that operates on query parameters model which is only an internal
   * model.
   *
   * This does nothing if the query parameter has not been defined for current
   * scheme.
   *
   * @param name The name of the changed parameter
   * @param newValue A value to apply. May be empty but must be defined.
   */
  updateQueryParameter(name: string, newValue?: string): void {
    const instance = this[factory] as ApiUiBase;
    if (!instance) {
      // eslint-disable-next-line no-console
      console.warn(`Setting a query parameter before "type" was set.`);
      return;
    }
    let setValue = newValue;
    if (setValue === null || setValue === undefined) {
      setValue = '';
    }
    if (typeof instance.updateQueryParameter === 'function') {
      instance.updateQueryParameter(name, setValue);
    }
  }

  /**
   * Updates, if applicable, header value.
   * This is supported for RAML custom scheme and Pass Through
   * that operates on headers model which is only an internal model.
   *
   * This does nothing if the header has not been defined for current
   * scheme.
   *
   * @param name The name of the changed header
   * @param newValue A value to apply. May be empty but must be defined.
   */
  updateHeader(name: string, newValue?: string): void {
    const instance = this[factory] as ApiUiBase;
    if (!instance) {
      // eslint-disable-next-line no-console
      console.warn(`Setting a query parameter before "type" was set.`);
      return;
    }
    let setValue = newValue;
    if (setValue === null || setValue === undefined) {
      setValue = '';
    }
    if (typeof instance.updateHeader === 'function') {
      instance.updateHeader(name, setValue);
    }
  }

  /**
   * Updates, if applicable, cookie value.
   * This is supported in OAS' Api Key.
   *
   * This does nothing if the cookie has not been defined for current
   * scheme.
   *
   * @param name The name of the changed cookie
   * @param newValue A value to apply. May be empty but must be defined.
   */
  updateCookie(name: string, newValue?: string): void {
    const instance = this[factory] as ApiUiBase;
    if (!instance) {
      // eslint-disable-next-line no-console
      console.warn(`Setting a query parameter before "type" was set.`);
      return;
    }
    let setValue = newValue;
    if (setValue === null || setValue === undefined) {
      setValue = '';
    }
    if (typeof instance.updateCookie === 'function') {
      instance.updateCookie(name, setValue);
    }
  }
}
