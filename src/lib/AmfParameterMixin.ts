/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable no-unused-vars */
/* eslint-disable class-methods-use-this */
/* eslint-disable arrow-body-style */
// eslint-disable-next-line no-unused-vars
import { html, TemplateResult } from 'lit';
import { dedupeMixin } from '@open-wc/dedupe-mixin';
import '@anypoint-web-components/awc/dist/define/anypoint-dropdown-menu.js';
import '@anypoint-web-components/awc/dist/define/anypoint-listbox.js';
import '@anypoint-web-components/awc/dist/define/anypoint-item.js';
import '@anypoint-web-components/awc/dist/define/anypoint-input.js';
import '@anypoint-web-components/awc/dist/define/anypoint-checkbox.js';
import '@anypoint-web-components/awc/dist/define/anypoint-button.js';
import '@anypoint-web-components/awc/dist/define/anypoint-icon-button.js';
import '@anypoint-web-components/awc/dist/define/anypoint-switch.js';
import { AnypointListboxElement, SupportedInputTypes, AnypointCheckboxElement, AnypointSwitchElement } from '@anypoint-web-components/awc';
import '@advanced-rest-client/icons/arc-icon.js';
import { ifDefined } from 'lit/directives/if-defined.js'
import { classMap } from 'lit/directives/class-map.js';
import { ApiSchemaValues } from '../schema/ApiSchemaValues.js';
import { ns } from '../helpers/Namespace.js';
import * as InputCache from './InputCache.js';
import { readLabelValue } from './Utils.js';
import { OperationParameter, ShapeTemplateOptions, ParameterRenderOptions } from '../types.js';
import { ApiAnyShape, ApiArrayShape, ApiParameter, ApiScalarNode, ApiScalarShape, ApiShapeUnion, ApiTupleShape, ApiUnionShape } from '../helpers/api.js';

type Constructor<T = {}> = new (...args: any[]) => T;

export const customParamTemplate = Symbol('customParamTemplate');
export const customParamChangeHandler = Symbol('customParamChangeHandler');
export const deleteParamHandler = Symbol('deleteParamHandler');
export const correctDateTimeParameter = Symbol('correctDateTimeParameter');

/**
 * This mixin adds support for rendering operation parameter inputs.
 * It support:
 * - rendering inputs
 * - caching user input
 * - restoring cache input.
 * 
 * @mixin
 */
export interface AmfParameterMixinInterface {
  /**
   * By default the element stores user input in a map that is associated with the specific
   * instance of this element. This way the element can be used multiple times in the same document.
   * However, this way parameter values generated by the generators or entered by the user won't 
   * get populated in different operations.
   * 
   * By setting this value the element prefers a global cache for values. Once the user enter
   * a value it is registered in the global cache and restored when the same parameter is used again.
   * 
   * Do not use this option when the element is embedded multiple times in the page. It will result
   * in generating request data from the cache and not what's in the form inputs and these may not be in sync.
   * 
   * These values are stored in memory only. Listen to the `change` event to learn that something changed.
   * @attribute;
   */
  globalCache: boolean;
  parametersValue: OperationParameter[];
  nilValues: string[];

  /**
   * A function to be overwritten by child classes to execute an action when a parameter has changed.
   * @param key The key of the property that changed.
   */
  paramChanged(key: string): void;

  /**
   * Clears previously set values in the cache storage.
   */
  clearCache(): void;

  connectedCallback(): void;

  addArrayValueHandler(e: Event): void;

  /**
   * Reads the value to be set on an input.
   * 
   * @param isArray Whether the value should be read for an array.
   * @returns The value to set on the input. Note, it is not cast to the type.
   */
  readInputValue(parameter: ApiParameter, schema: ApiScalarShape, isArray?: boolean): any;
  paramChangeHandler(e: Event): void;
  booleanHandler(e: Event): void;
  /**
   * A handler for the remove param button click.
   */
  deleteParamHandler(e: Event): void;
  enumSelectionHandler(e: Event): void;
  /**
   * Handler for the nil value toggle.
   */
  nilHandler(e: Event): void;
  /**
   * @returns The template for the request parameter form control.
   */
  parameterTemplate(param: OperationParameter, opts?: ParameterRenderOptions): TemplateResult | string;

  /**
   * @returns The template for the request parameter form control.
   */
  parameterSchemaTemplate(parameter: ApiParameter, schema: ApiShapeUnion, userOpts?: ParameterRenderOptions, opts?: ShapeTemplateOptions): TemplateResult | string;

  /**
   * @returns The template for the schema parameter.
   */
  scalarShapeTemplate(parameter: ApiParameter, schema: ApiScalarShape, userOpts?: ParameterRenderOptions, opts?: ShapeTemplateOptions): TemplateResult | string;

  /**
   * @return A template for an input form item for the given type and schema
   */
  textInputTemplate(parameter: ApiParameter, schema: ApiScalarShape, type?: SupportedInputTypes, userOpts?: ParameterRenderOptions, opts?: ShapeTemplateOptions): TemplateResult;

  /**
   * @param paramId The ApiParameter id.
   * @param arrayIndex When this is an array item, the index on the array.
   * @returns The template for the param remove button. 
   */
  deleteParamTemplate(paramId: string, arrayIndex?: number): TemplateResult;

  /**
   * @returns The template for the enum input.
   */
  enumTemplate(parameter: ApiParameter, schema: ApiScalarShape, userOpts?: ParameterRenderOptions, opts?: ShapeTemplateOptions): TemplateResult;

  /**
   * @returns The template for the checkbox input.
   */
  booleanTemplate(parameter: ApiParameter, schema: ApiScalarShape, opts?: ShapeTemplateOptions): TemplateResult;

  /**
   * @returns The template for the nil checkbox input.
   */
  nillInputTemplate(parameter: ApiParameter): TemplateResult;

  /**
   * or now we do not support union shapes. There's no way to learn how to serialize
   * the Node shape to a string.
   * @returns The template for the node shape.
   */
  nodeShapeTemplate(): TemplateResult | string;

  /**
   * @returns The template for the union shape.
   */
  unionShapeTemplate(parameter: ApiParameter, schema: ApiUnionShape): TemplateResult | string;

  /**
   * This situation makes not sense as there's no mechanism to describe how to 
   * put a file into a path, query, or headers.
   * @returns The template for the file shape.
   */
  fileShapeTemplate(): TemplateResult | string;

  /**
   * For now we do not support union shapes. There's no way to learn how to serialize
   * the Schema shape to a string.
   * @returns The template for the schema shape.
   */
  schemaShapeTemplate(): TemplateResult | string;

  /**
   * @returns The template for the array shape.
   */
  arrayShapeTemplate(parameter: ApiParameter, schema: ApiArrayShape): TemplateResult | string;

  /**
   * @returns The template for the tuple shape.
   */
  tupleShapeTemplate(parameter: ApiParameter, schema: ApiTupleShape): TemplateResult | string;

  /**
   * @returns The template for the Any shape.
   */
  anyShapeTemplate(parameter: ApiParameter, schema: ApiAnyShape): TemplateResult | string;

  /**
   * @param {string} id The id of the parameter to add the value to.
   * @returns The template for the adding an array item button
   */
  addArrayItemTemplate(id: string): TemplateResult;
}

/**
 * This mixin adds support for rendering operation parameter inputs.
 * It support:
 * - rendering inputs
 * - caching user input
 * - restoring cache input.
 * 
 * @mixin
 */
export const AmfParameterMixin = dedupeMixin(<T extends Constructor<any>>(superClass: T): Constructor<AmfParameterMixinInterface> & T => {
  

  class AmfParameterMixinClass extends superClass {

    parametersValue: OperationParameter[];

    nilValues: string[];

    constructor(...args: any[]) {
      super(...args);
      this.globalCache = false;
      this.parametersValue = [];
      this.nilValues = [];

      this.addArrayValueHandler = this.addArrayValueHandler.bind(this);
      this.paramChangeHandler = this.paramChangeHandler.bind(this);
      this.booleanHandler = this.booleanHandler.bind(this);
      this[deleteParamHandler] = this[deleteParamHandler].bind(this);
      this.enumSelectionHandler = this.enumSelectionHandler.bind(this);
      this.nilHandler = this.nilHandler.bind(this);
      this[customParamChangeHandler] = this[customParamChangeHandler].bind(this);
    }

    /**
     * A function to be overwritten by child classes to execute an action when a parameter has changed.
     * @param key The key of the property that changed.
     */
    paramChanged(key: string): void {
      // ...
    }

    /**
     * Clears previously set values in the cache storage.
     */
    clearCache(): void {
      const params = this.parametersValue;
      (params || []).forEach((param) => {
        InputCache.remove(this.target, param.paramId, this.globalCache)
      });
    }

    addArrayValueHandler(e: Event): void {
      const button = e.target as HTMLElement;
      const { id } = button.dataset;
      if (!id) {
        return;
      }
      if (!InputCache.has(this.target, id, this.globalCache)) {
        InputCache.set(this.target, id, [], this.globalCache);
      }
      const items = (InputCache.get(this.target, id, this.globalCache)) as any[];
      items.push(undefined);
      this.requestUpdate();
      this.paramChanged(id);
    }

    /**
     * Reads the value to be set on an input.
     * 
     * @param parameter
     * @param schema
     * @param isArray Whether the value should be read for an array.
     * @returns The value to set on the input. Note, it is not cast to the type.
     */
    readInputValue(parameter: ApiParameter, schema: ApiScalarShape, isArray=false): any {
      const { id } = parameter;
      if (InputCache.has(this.target, id, this.globalCache)) {
        return InputCache.get(this.target, id, this.globalCache);
      }
      let result;
      if (parameter.required) {
        const opts = { fromExamples: true };
        if (isArray) {
          result = ApiSchemaValues.readInputValues(parameter, schema, opts);
        } else {
          result = ApiSchemaValues.readInputValue(parameter, schema, opts);
        }
        if (result !== undefined) {
          InputCache.set(this.target, id, result, this.globalCache);
        }
      }
      return result;
    }

    paramChangeHandler(e: Event): void {
      const input = e.target as HTMLInputElement;
      const { value, dataset } = input;
      const { domainId, isArray, index } = dataset;
      if (!domainId) {
        return;
      }
      const param = this.parametersValue.find(p => p.paramId === domainId);
      if (!param) {
        return;
      }
      // sets cached value of the input.
      const typed = ApiSchemaValues.parseUserInput(value, param.schema as ApiShapeUnion);
      InputCache.set(this.target, domainId, typed, this.globalCache, isArray === 'true', index ? Number(index) : undefined);
      this.notifyChange();
      this.paramChanged(domainId);
    }

    booleanHandler(e: Event): void {
      const input = e.target as AnypointCheckboxElement;
      const { checked, dataset } = input;
      const { domainId, isArray, index } = dataset;
      if (!domainId) {
        return;
      }
      const param = this.parametersValue.find(p => p.paramId === domainId);
      if (!param) {
        return;
      }
      InputCache.set(this.target, domainId, checked, this.globalCache, isArray === 'true', index ? Number(index) : undefined);
      this.notifyChange();
      this.paramChanged(domainId);
    }

    /**
     * A handler for the remove param button click.
     */
    [deleteParamHandler](e: Event): void {
      const button = e.currentTarget as HTMLElement;
      const { dataset } = button;
      const { domainId, index, deleteParam } = dataset;
      if (!domainId) {
        return;
      }
      let forceUpdate = false;
      if (deleteParam === 'true') {
        const pIndex = this.parametersValue.findIndex(p => p.paramId === domainId);
        this.parametersValue.splice(pIndex, 1);
        forceUpdate = true;
      }
      if (InputCache.has(this.target, domainId, this.globalCache)) {
        InputCache.remove(this.target, domainId, this.globalCache, index ? Number(index) : undefined);
        forceUpdate = true;
      }
      if (forceUpdate) {
        this.requestUpdate();
        this.notifyChange();
        this.paramChanged(domainId);
      }
    }

    enumSelectionHandler(e: Event): void {
      const list = e.target as AnypointListboxElement;
      const select = list.parentElement as HTMLElement;
      const { domainId, isArray, index } = select.dataset;
      if (!domainId) {
        return;
      }
      const param = this.parametersValue.find(p => p.paramId === domainId);
      if (!param) {
        return;
      }
      const enumValues = ((param.schema as ApiShapeUnion).values as ApiScalarNode[]);
      const { value } = enumValues[list.selected as number];
      const typed = ApiSchemaValues.parseUserInput(value, param.schema as ApiShapeUnion);
      InputCache.set(this.target, domainId, typed, this.globalCache, isArray === 'true', index ? Number(index) : undefined);
      this.notifyChange();
      this.paramChanged(domainId);
    }

    /**
     * Handler for the nil value toggle.
     */
    nilHandler(e: Event): void {
      const button = e.target as AnypointCheckboxElement;
      const { checked, dataset } = button;
      const { domainId } = dataset;
      if (!domainId) {
        return;
      }
      const list = this.nilValues;
      const has = list.includes(domainId);
      if (checked && !has) {
        list.push(domainId);
        this.requestUpdate();
      } else if (!checked && has) {
        const index = list.indexOf(domainId);
        list.splice(index, 1);
        this.requestUpdate();
      }
      this.notifyChange();
      this.paramChanged(domainId);
    }

    /**
     * @param param The parameter to render.
     * @param opts Render options
     * @returns The template for the request parameter form control.
     */
    parameterTemplate(param: OperationParameter, opts: ParameterRenderOptions={}): TemplateResult | string {
      const { schema, parameter, source } = param;
      if (source === 'custom') {
        return this[customParamTemplate](param);
      }
      if (!schema) {
        return '';
      }
      return this.parameterSchemaTemplate(parameter, schema, opts);
    }

    /**
     * @param parameter
     * @param schema
     * @param opts Internal Process options
     * @returns The template for the request parameter form control.
     */
    parameterSchemaTemplate(parameter: ApiParameter, schema: ApiShapeUnion, opts: ShapeTemplateOptions={}): TemplateResult | string {
      const { types } = schema;
      if (types.includes(ns.aml.vocabularies.shapes.ScalarShape)) {
        return this.scalarShapeTemplate(parameter, schema as ApiScalarShape, opts);
      }
      if (types.includes(ns.w3.shacl.NodeShape)) {
        return this.nodeShapeTemplate();
      }
      if (types.includes(ns.aml.vocabularies.shapes.UnionShape)) {
        return this.unionShapeTemplate(parameter, schema as ApiUnionShape);
      }
      if (types.includes(ns.aml.vocabularies.shapes.FileShape)) {
        return this.fileShapeTemplate();
      }
      if (types.includes(ns.aml.vocabularies.shapes.SchemaShape)) {
        return this.schemaShapeTemplate();
      }
      if (types.includes(ns.aml.vocabularies.shapes.ArrayShape) || types.includes(ns.aml.vocabularies.shapes.MatrixShape)) {
        return this.arrayShapeTemplate(parameter, schema as ApiArrayShape);
      }
      if (types.includes(ns.aml.vocabularies.shapes.TupleShape)) {
        return this.tupleShapeTemplate(parameter, schema as ApiTupleShape);
      }
      return this.anyShapeTemplate(parameter, schema as ApiAnyShape);
    }

    /**
     * @param parameter
     * @param schema
     * @param opts
     * @returns The template for the schema parameter.
     */
    scalarShapeTemplate(parameter: ApiParameter, schema: ApiScalarShape, opts: ShapeTemplateOptions={}): TemplateResult | string {
      const { readOnly, values, dataType='text' } = schema;
      if (readOnly) {
        return '';
      }
      if (values && values.length) {
        return this.enumTemplate(parameter, schema, opts);
      }
      const inputType = ApiSchemaValues.readInputType(dataType);
      if (inputType === 'boolean') {
        return this.booleanTemplate(parameter, schema, opts);
      }
      return this.textInputTemplate(parameter, schema, inputType, opts);
    }

    /**
     * Corrects the `http://www.w3.org/2001/XMLSchema#dateTime` schema with the `date-time` or `rfc3339` formats
     * to remove the last `.ZZZ` part which is not recognizable by the `<input>` element.
     */
    [correctDateTimeParameter](schema: ApiScalarShape, value: any): any {
      if (!value) {
        return value;
      }
      if (schema.dataType === ns.w3.xmlSchema.dateTime) {
        if (['date-time', 'rfc3339'].includes(schema.format || '')) {
          return String(value).replace(/(\.\d\d\d)Z/, '$1');
        }
      }
      return value;
    }

    /**
     * @param parameter
     * @param schema
     * @param type The input type.
     * @param opts
     * @returns A template for an input form item for the given type and schema
     */
    textInputTemplate(parameter: ApiParameter, schema: ApiScalarShape, type?: SupportedInputTypes, opts: ShapeTemplateOptions={}): TemplateResult {
      const { id, binding, } = parameter;
      const { pattern, minimum, minLength, maxLength, maximum, multipleOf } = schema;
      let required = false;
      if (typeof opts.required === 'boolean') {
        required = opts.required;
      } else {
        required = parameter.required || false;
      }
      const label = readLabelValue(parameter, schema);
      const { allowEmptyValue, } = parameter;
      let value;
      if (opts.arrayItem) {
        value = opts.value || '';
      } else {
        value = this.readInputValue(parameter, schema);
      }
      if (value) {
        value = ApiSchemaValues.parseScalarInput(value, schema);
        value = this[correctDateTimeParameter](schema, value);
      }
      let step: number | undefined;
      if (['time', 'datetime-local'].includes(type || '')) {
        step = 1;
      } else if (typeof multipleOf !== 'undefined') {
        step = Number(multipleOf);
      }
      const title = parameter.description || schema.description;
      const nillable = this.nilValues;
      const nillDisabled = !!opts.nillable && nillable.includes(id);
      const classes = {
        'form-item': true,
        required,
        optional: !required,
      };
      return html`
      <div class="${classMap(classes)}">
        <anypoint-input 
          data-domain-id="${id}"
          data-is-array="${ifDefined(opts.arrayItem)}"
          data-index="${ifDefined(opts.index)}"
          data-binding="${ifDefined(binding)}"
          name="${parameter.name || schema.name || ''}" 
          class="form-input"
          ?required="${required && !allowEmptyValue}"
          ?autoValidate="${required && !allowEmptyValue}"
          .value="${value}"
          .pattern="${pattern}"
          .min="${typeof minimum !== 'undefined' ? minimum : undefined}"
          .minLength="${minLength}"
          .max="${typeof maximum !== 'undefined' ? maximum : undefined}"
          .maxLength="${maxLength}"
          .step="${ifDefined(step)}"
          type="${ifDefined(type)}"
          title="${ifDefined(title)}"
          @change="${this.paramChangeHandler}"
          ?disabled="${nillDisabled}"
          ?anypoint="${this.anypoint}"
          ?outlined="${this.outlined}"
          label="${label}"
        ></anypoint-input>
        ${opts.nillable ? this.nillInputTemplate(parameter) : ''}
        ${opts.arrayItem ? this.deleteParamTemplate(id, opts.index) : ''}
      </div>
      `;
    }

    /**
     * @param paramId The ApiParameter id.
     * @param arrayIndex When this is an array item, the index on the array.
     * @returns The template for the param remove button. 
     */
    deleteParamTemplate(paramId: string, arrayIndex?: number): TemplateResult {
      const { anypoint } = this;
      const title = 'Removes this parameter.';
      return html`
      <anypoint-icon-button 
        ?anypoint="${anypoint}" 
        title="${title}" 
        data-domain-id="${paramId}"
        data-index="${ifDefined(arrayIndex)}"
        data-delete-param="true"
        @click="${this[deleteParamHandler]}"
      >
        <arc-icon icon="removeCircleOutline"></arc-icon>
      </anypoint-icon-button>
      `;
    }

    /**
     * @param parameter
     * @param schema
     * @param opts
     * @returns The template for the enum input.
     */
    enumTemplate(parameter: ApiParameter, schema: ApiScalarShape, opts: ShapeTemplateOptions={}): TemplateResult | string {
      const { anypoint } = this;
      let required = false;
      if (typeof opts.required === 'boolean') {
        required = opts.required;
      } else {
        required = parameter.required || false;
      }
      const label = readLabelValue(parameter, schema);
      const enumValues = (schema.values || []) as ApiScalarNode[];
      const selectedValue = this.readInputValue(parameter, schema);
      const selected = enumValues.findIndex(i => i.value === selectedValue);
      const { id, binding } = parameter;
      const title = parameter.description || schema.description;
      const nillable = this.nilValues;
      const nillDisabled = !!opts.nillable && nillable.includes(id);
      const classes = {
        'form-item': true,
        required,
        optional: !required,
      };
      return html`
      <div class="${classMap(classes)}">
        <anypoint-dropdown-menu
          class="param-selector"
          name="${parameter.name || schema.name || ''}"
          data-binding="${ifDefined(binding)}"
          ?outlined="${this.outlined}"
          ?anypoint="${anypoint}"
          ?required="${required}"
          title="${ifDefined(title)}"
          fitPositionTarget
          dynamicAlign
          data-domain-id="${id}"
          data-is-array="${ifDefined(opts.arrayItem)}"
          ?disabled="${nillDisabled}"
        >
          <label slot="label">${label}</label>
          <anypoint-listbox
            slot="dropdown-content"
            ?anypoint="${anypoint}"
            .selected="${selected}"
            @selected="${this.enumSelectionHandler}"
          >
            ${enumValues.map((value) => html`<anypoint-item ?anypoint="${anypoint}" data-type="${ifDefined(value.dataType)}" data-value="${ifDefined(value.value)}">${value.value}</anypoint-item>`)}
          </anypoint-listbox>
        </anypoint-dropdown-menu>
        ${opts.nillable ? this.nillInputTemplate(parameter) : ''}
      </div>
      `;
    }

    /**
     * @returns The template for the checkbox input.
     */
    booleanTemplate(parameter: ApiParameter, schema: ApiScalarShape, opts: ShapeTemplateOptions={}): TemplateResult | string {
      const label = readLabelValue(parameter, schema);
      const { id } = parameter;
      let value: boolean;
      if (opts.arrayItem) {
        value = opts.value || '';
      } else {
        value = this.readInputValue(parameter, schema);
      }
      const title = parameter.description || schema.description;
      const nillable = this.nilValues;
      const nillDisabled = !!opts.nillable && nillable.includes(id);
      const classes = {
        'form-item': true,
        required: parameter.required || false,
        optional: !parameter.required,
      };
      // note, don't mark a checkbox as required. A checkbox also produces `false` value
      // which should be passed to the transport. The request data processor should take care of
      // producing the right output.
      return html`
      <div class="${classMap(classes)}">
        <anypoint-checkbox 
          class="boolean-param"
          name="${parameter.name || schema.name || ''}"
          data-binding="${ifDefined(parameter.binding)}"
          .checked="${value}"
          title="${ifDefined(title)}"
          data-domain-id="${id}"
          data-is-array="${ifDefined(opts.arrayItem)}"
          ?disabled="${nillDisabled}"
          @change="${this.booleanHandler}"
        >${label}</anypoint-checkbox>
        ${opts.nillable ? this.nillInputTemplate(parameter) : ''}
      </div>
      `;
    }

    /**
     * @returns The template for the nil checkbox input.
     */
    nillInputTemplate(parameter: ApiParameter): TemplateResult | string {
      return html`
      <anypoint-checkbox 
        class="nil-option"
        data-domain-id="${parameter.id}"
        data-binding="${ifDefined(parameter.binding)}"
        title="Makes the property nillable (e.g. inserts null into the schema)"
        @change="${this.nilHandler}"
      >Nil</anypoint-checkbox>
      `;
    }

    /**
     * or now we do not support union shapes. There's no way to learn how to serialize
     * the Node shape to a string.
     * @returns {TemplateResult|string} The template for the node shape.
     */
    nodeShapeTemplate(): TemplateResult | string {
      return '';
    }

    /**
     * @returns The template for the union shape.
     */
    unionShapeTemplate(parameter: ApiParameter, schema: ApiUnionShape): TemplateResult | string {
      const { anyOf } = schema;
      if (!anyOf || !anyOf.length) {
        return '';
      }
      const nil = anyOf.find(shape => shape.types.includes(ns.aml.vocabularies.shapes.NilShape));
      if (nil && anyOf.length === 2) {
        // this is a case where a scalar is marked as nillable instead of not required
        // (which for some reason is a common practice among RAML developers).
        const scalar = anyOf.find(shape => shape !== nil) as ApiShapeUnion;
        return this.parameterSchemaTemplate(parameter, scalar, {
          nillable: true,
        });
      }
      const hasComplex = anyOf.some(i => !i.types.includes(ns.aml.vocabularies.shapes.ScalarShape));
      const hasScalar = anyOf.some(i => i.types.includes(ns.aml.vocabularies.shapes.ScalarShape));
      if (hasComplex && !hasScalar) {
        // We quit here as this is the same problem as with the Node shape - unclear how to serialize the types
        return '';
      }
      // at this point only scalars are possible. For that we render a regular text field 
      // and while serializing the values we figure out what type it should be giving the 
      // value provided and available types in the union.
      let opts: ShapeTemplateOptions | undefined;
      if (nil) {
        opts = { nillable: true };
      }
      return this.textInputTemplate(parameter, schema, 'text', opts);
    }

    /**
     * This situation makes not sense as there's no mechanism to describe how to 
     * put a file into a path, query, or headers.
     * @returns The template for the file shape.
     */
    fileShapeTemplate(): TemplateResult | string {
      return '';
    }

    /**
     * For now we do not support union shapes. There's no way to learn how to serialize
     * the Schema shape to a string.
     * @returns The template for the schema shape.
     */
    schemaShapeTemplate(): TemplateResult | string {
      return '';
    }

    /**
     * @returns The template for the array shape.
     */
    arrayShapeTemplate(parameter: ApiParameter, schema: ApiArrayShape): TemplateResult | string {
      const { items } = schema;
      if (!items) {
        return '';
      }
      const { id } = parameter;
      const label = readLabelValue(parameter, schema);
      const values = (this.readInputValue(parameter, schema, true)) as any[];
      const options = { arrayItem: true, };
      const inputs = (values || []).map((value, index) => this.parameterSchemaTemplate(parameter, items, { ...options, value, index }));
      const classes = {
        'array-form-item': true,
        required: !!parameter.required,
        optional: !parameter.required,
      };
      return html`
      <div class="${classMap(classes)}" data-param-id="${id}" data-param-label="${label}">
        <div class="array-title"><span class="label">${label}</span></div>
        ${inputs}
        ${this.addArrayItemTemplate(id)}
      </div>
      `;
    }

    /**
     * @returns The template for the tuple shape.
     */
    tupleShapeTemplate(parameter: ApiParameter, schema: ApiTupleShape): TemplateResult | string {
      const { items } = schema;
      if (!items) {
        return '';
      }
      // TODO: not sure how to process this value...
      return '';
    }

    /**
     * @returns The template for the Any shape.
     */
    anyShapeTemplate(parameter: ApiParameter, schema: ApiAnyShape): TemplateResult | string {
      return this.textInputTemplate(parameter, schema, 'text');
    }

    /**
     * @param id The id of the parameter to add the value to.
     * @returns The template for the adding an array item button
     */
    addArrayItemTemplate(id: string): TemplateResult | string {
      return html`
      <anypoint-button data-id="${id}" @click="${this.addArrayValueHandler}">Add new value</anypoint-button>
      `;
    }

    /**
     * Handler for a custom parameter input change.
     */
    [customParamChangeHandler](e: Event): void {
      const input = e.target as HTMLInputElement;
      const { value, name, dataset } = input;
      const { domainId } = dataset;
      if (!domainId || !['paramName', 'paramValue'].includes(name)) {
        return;
      }
      if (name === 'paramName') {
        const param = this.parametersValue.find(item => item.paramId === domainId);
        if (!param) {
          return;
        }
        param.parameter.name = value;
      } else {
        InputCache.set(this.target, domainId, value, this.globalCache);
      }
      this.notifyChange();
      this.paramChanged(domainId);
    }

    /**
     * @param param The parameter to render
     * @returns The template for a custom parameter
     */
    [customParamTemplate](param: OperationParameter): TemplateResult {
      const value = InputCache.get(this.target, param.paramId, this.globalCache) as string;
      const classes = {
        'form-item': true,
        'custom-item': true,
      };
      let nameLabel;
      let nameTitle;
      let valueLabel;
      let valueTitle;
      if (param.binding === 'query') {
        nameLabel = 'Query parameter'
        nameTitle = 'The name of this query parameter';
        valueLabel = 'Parameter value';
        valueTitle = 'The value of this query parameter';
      } else if (param.binding === 'header') {
        nameLabel = 'Header name'
        nameTitle = 'The name of this header';
        valueLabel = 'Header value';
        valueTitle = 'The value of this header';
      } else {
        nameLabel = 'Parameter name'
        nameTitle = 'The name of the parameter';
        valueLabel = 'Parameter value';
        valueTitle = 'The value of the parameter';
      }
      return html`
      <div class="${classMap(classes)}">
        <anypoint-input 
          data-domain-id="${param.paramId}"
          data-binding="${param.binding}"
          class="form-input custom-name"
          .value="${param.parameter.name}"
          title="${nameTitle}"
          name="paramName"
          @change="${this[customParamChangeHandler]}"
          ?anypoint="${this.anypoint}"
          ?outlined="${this.outlined}"
          noLabelFloat
          label="${nameLabel}"
        ></anypoint-input>
        <anypoint-input 
          data-domain-id="${param.paramId}"
          data-binding="${param.binding}"
          class="form-input custom-value"
          .value="${value}"
          title="${valueTitle}"
          name="paramValue"
          @change="${this[customParamChangeHandler]}"
          ?anypoint="${this.anypoint}"
          ?outlined="${this.outlined}"
          noLabelFloat
          label="${valueLabel}"
        ></anypoint-input>
        ${this.deleteParamTemplate(param.paramId)}
      </div>
      `;
    }
  }

  return AmfParameterMixinClass as Constructor<AmfParameterMixinInterface> & T;
});
